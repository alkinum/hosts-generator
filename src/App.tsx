import React, { useState, useEffect } from 'react';
import { BackgroundEffects } from './components/BackgroundEffects';
import { HeaderBar } from './components/HeaderBar';
import { InputPanel } from './components/InputPanel';
import { TerminalOutput } from './components/TerminalOutput';
import { PreviewSection } from './components/PreviewSection';
import { HistorySidebar } from './components/HistorySidebar';
import { useTerminal } from './hooks/useTerminal';
import { useDNSResolver } from './hooks/useDNSResolver';
import { validateDomains } from './utils/validation';
import { historyDB } from './utils/indexedDB';
import { DOH_PROVIDERS } from './utils/constants';
import { DNSResult, DOHProvider } from './types';
import packageJson from '../package.json';

function App() {
  const [domains, setDomains] = useState('');
  const [results, setResults] = useState<DNSResult[]>([]);
  const [selectedProvider, setSelectedProvider] = useState<DOHProvider>(DOH_PROVIDERS[0]);
  const [showProviderMenu, setShowProviderMenu] = useState(false);
  const [includeLocalhost, setIncludeLocalhost] = useState(false);
  const [removeComments, setRemoveComments] = useState(false);
  const [validationErrors, setValidationErrors] = useState<string[]>([]);
  const [showHistory, setShowHistory] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);

  const {
    terminalOutput,
    currentLine,
    addToTerminal,
    typeToTerminal,
    resetTerminal
  } = useTerminal([
    `hosts-generator v${packageJson.version}`,
    `DNS resolution via ${selectedProvider.label}`,
    '',
    'Ready to process domains...',
    ''
  ]);

  const { isResolving, resolveDomains } = useDNSResolver({
    onProgress: (domain, result, index) => {
      if (!result.ip) {
        typeToTerminal(`Resolving ${domain}...`, 0);
      } else {
        if (result.ip) {
          addToTerminal(`✓ ${domain} → ${result.ip}`, 0);
        } else {
          addToTerminal(`✗ ${domain} → ${result.error || 'Failed'}`, 0);
        }
      }
    }
  });

  // Initialize IndexedDB
  useEffect(() => {
    historyDB.init().catch(console.error);
  }, []);

  // Update terminal when provider changes
  useEffect(() => {
    resetTerminal([
      `hosts-generator v${packageJson.version}`,
      `DNS resolution via ${selectedProvider.label}`,
      '',
      'Ready to process domains...',
      ''
    ]);
  }, [selectedProvider, resetTerminal]);

  const saveToHistory = async () => {
    if (results.length === 0) return;
    
    try {
      await historyDB.addRecord({
        inputContent: domains,
        outputContent: generateHostsFile(),
        timestamp: Date.now(),
        successCount: results.filter(r => r.ip).length,
        totalCount: results.length,
        provider: selectedProvider.label
      });
    } catch (error) {
      console.error('Failed to save to history:', error);
    }
  };

  const handleResolve = async () => {
    if (!domains.trim()) return;

    const { domains: validDomains, errors } = validateDomains(domains);
    setValidationErrors(errors);
    
    if (errors.length > 0) {
      addToTerminal('$ hosts-generator --validate', 0);
      addToTerminal('', 100);
      errors.forEach((error, index) => {
        addToTerminal(`✗ ${error}`, 200 + index * 100);
      });
      addToTerminal('', 200 + errors.length * 100);
      addToTerminal('Validation failed. Please fix errors and try again.', 300 + errors.length * 100);
      return;
    }

    if (validDomains.length === 0) {
      addToTerminal('✗ No valid domains to resolve', 0);
      return;
    }

    setResults([]);

    addToTerminal(`$ hosts-generator --resolve --provider=${selectedProvider.name}`, 0);
    addToTerminal('', 100);
    typeToTerminal('Initializing DNS resolver...', 200);
    addToTerminal(`Found ${validDomains.length} domains to resolve`, 1500);
    addToTerminal(`Using ${selectedProvider.label} DNS over HTTPS`, 1600);
    addToTerminal(`Max concurrent requests: 5`, 1700);
    addToTerminal('', 1800);

    try {
      const resolvedResults = await resolveDomains(validDomains, selectedProvider);
      
      setTimeout(() => {
        addToTerminal('', 500);
        addToTerminal('DNS resolution completed.', 600);
        addToTerminal(`Successfully resolved ${resolvedResults.filter(r => r.ip).length}/${validDomains.length} domains`, 700);
        setResults(resolvedResults);
        
        // Save to history after successful resolution
        setTimeout(() => {
          saveToHistory();
        }, 1000);
      }, validDomains.length * 200 + 2000);
    } catch (error) {
      addToTerminal('✗ Resolution process failed', 0);
    }
  };

  const generateHostsFile = () => {
    let content: string[] = [];
    
    if (!removeComments) {
      const header = includeLocalhost ? [
        '# Hosts file generated by hosts-generator',
        `# Generated on: ${new Date().toISOString()}`,
        `# Resolved using ${selectedProvider.label} DNS over HTTPS`,
        '',
        '# Default localhost entries',
        '127.0.0.1 localhost',
        '::1 localhost',
        '',
        '# Custom entries'
      ] : [
        '# Hosts file generated by hosts-generator',
        `# Generated on: ${new Date().toISOString()}`,
        `# Resolved using ${selectedProvider.label} DNS over HTTPS`,
        '',
        '# Custom entries'
      ];
      content = [...header];
    } else if (includeLocalhost) {
      content = [
        '127.0.0.1 localhost',
        '::1 localhost'
      ];
    }

    const entries = results
      .filter(result => result.ip)
      .map(result => `${result.ip} ${result.domain}`);

    return [...content, ...entries].join('\n');
  };

  const downloadHostsFile = () => {
    const content = generateHostsFile();
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'hosts';
    a.click();
    URL.revokeObjectURL(url);
  };

  const clearAll = () => {
    setDomains('');
    resetTerminal([
      'hosts-generator v2.1.0',
      `DNS resolution via ${selectedProvider.label}`,
      '',
      'Ready to process domains...',
      ''
    ]);
    setResults([]);
    setValidationErrors([]);
  };

  const handleProviderSelect = (provider: DOHProvider) => {
    setSelectedProvider(provider);
    setShowProviderMenu(false);
  };

  const toggleProviderMenu = () => {
    if (showProviderMenu) {
      setShowProviderMenu(false);
    } else {
      setShowProviderMenu(true);
    }
  };

  // Window control handlers
  const handleClose = () => {
    if (window.confirm('Are you sure you want to close the application?')) {
      window.close();
    }
  };

  const handleMinimize = () => {
    setIsMinimized(!isMinimized);
  };

  const handleToggleFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().then(() => {
        setIsFullscreen(true);
      }).catch((err) => {
        console.error('Error attempting to enable fullscreen:', err);
      });
    } else {
      document.exitFullscreen().then(() => {
        setIsFullscreen(false);
      }).catch((err) => {
        console.error('Error attempting to exit fullscreen:', err);
      });
    }
  };

  // Listen for fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
    };
  }, []);

  return (
    <div className={`min-h-screen bg-black text-green-400 font-mono relative overflow-hidden select-none transition-all duration-300 ${
      isMinimized ? 'transform scale-95 opacity-50' : ''
    }`}>
      <BackgroundEffects />

      <div className="relative z-10 p-4">
        <div className="max-w-7xl mx-auto">
          <HeaderBar
            selectedProvider={selectedProvider}
            providers={DOH_PROVIDERS}
            showProviderMenu={showProviderMenu}
            isResolving={isResolving}
            onProviderSelect={handleProviderSelect}
            onToggleProviderMenu={toggleProviderMenu}
            onShowHistory={() => setShowHistory(true)}
            isMinimized={isMinimized}
            onMinimize={handleMinimize}
            onToggleFullscreen={handleToggleFullscreen}
            onClose={handleClose}
          />

          <div className={`grid lg:grid-cols-3 gap-0 border-l border-r border-gray-700 transition-all duration-300 ${
            isMinimized ? 'opacity-30 pointer-events-none' : ''
          }`}>
            <InputPanel
              domains={domains}
              isResolving={isResolving}
              validationErrors={validationErrors}
              results={results}
              onDomainsChange={setDomains}
              onResolve={handleResolve}
              onClear={clearAll}
              onDownload={downloadHostsFile}
            />

            <TerminalOutput
              terminalOutput={terminalOutput}
              currentLine={currentLine}
            />
          </div>

          <PreviewSection
            className={`transition-all duration-300 ${
              isMinimized ? 'opacity-30 pointer-events-none' : ''
            }`}
            results={results}
            selectedProvider={selectedProvider}
            includeLocalhost={includeLocalhost}
            removeComments={removeComments}
            onIncludeLocalhostChange={setIncludeLocalhost}
            onRemoveCommentsChange={setRemoveComments}
            onDownload={downloadHostsFile}
          />
        </div>
      </div>
      
      <HistorySidebar
        isOpen={showHistory}
        onClose={() => setShowHistory(false)}
        onLoadRecord={(inputContent) => {
          setDomains(inputContent);
          setShowHistory(false);
        }}
      />
    </div>
  );
}

export default App;